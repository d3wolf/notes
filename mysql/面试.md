 Mysql 

## 事务的基本要素

原子性（Atomicity）

一致性（Consistency）

隔离性（Isolation）

持久性（Durability）

## 事务隔离级别

|      隔离级别                  | 脏读 | 不可重复| 幻读 |
|  ----                        | ---- |  ---   | --- |
| 未提交读（Read uncommitted）  | √    | √     | √    |
| 已提交读（Read committed）    | ×   |  √    |√    |
| 可重复读（Repeatable read）  | ×   |  ×    |√    |
| 可串行化（Serializable ）     | ×   |  ×   |×     |

* 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
* 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
* 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
* 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

Read Uncommitted这种级别，数据库一般都不会用，而且任何操作都不会加锁，这里就不讨论了。

## 不可重复读和幻读的区别

脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

很多人容易搞混不可重复读和幻读，确实这两者有些相似。

但不可重复读重点在于update和delete，而幻读的重点在于insert。

## 如何解决事务的并发问题(脏读，幻读)？

* 避免不可重复读锁行就行

> 针对update，使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据

* 避免幻读锁表就行

> 针对insert和delete操作,使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据

不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。

## MVCC多版本并发控制？

MVCC(Multiversion concurrency control) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制

> 每个连接到数据库的读者，在某个瞬间看到的是数据库的一个快照,写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的

> 当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。**这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。**对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。

>  MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用时间戳或者事务 ID去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。

## binlog,redolog,undolog都是什么，起什么作用？
   
##  InnoDB的行锁/表锁？

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁

## myisam和innodb的区别，什么时候选择myisam？
   
## 为什么选择B+树作为索引结构？
   
## 索引B+树的叶子节点都可以存哪些东西？
   
## 查询在什么时候不走（预期中的）索引？

* 统计信息不准确

* 索引列的值允许为NULL

* 谓词使用了不等于（<>, !=）

* LIKE前通配或全通配的查询

* 索引列使用了函数、数学运算、其它表达式等

* 使用了隐式类型转换

* 查询转换失败

* 其它语句逻辑原因
  
## sql如何优化?
  
## explain是如何解析sql的？
  
## order by原理

