## 	 Hystrix

https://www.cnblogs.com/zuowj/p/10418932.html

*  降级

> 在高并发的情况下，防止用户一直等待，使用服务降级方式进行处理(返回友好的提示给客户端，fallback回调方法)。当服务不可用的时候(正在等待的时候、网络延迟、响应时间过长),客户端会处于一直等待的状态。显然一直等待是不合理的，所以我们应该给客户端返回一个友好的提示，使用fallback(回调方法)进行服务降级处理。

>为了提高用户体验(自定义消息返回给客户端)，防止服务雪崩效应。比如：连接超时、网络延迟、服务器响应时间过长等情况。

*  隔离

> 每个服务接口之间互不影响，服务隔离有2种实现方式，线程池方式、信号量。
  
     1.线程池方式：相当于每个接口(服务)都有自己独立的线程池，不同的线程池之间互不影响，能够实现服务接口隔离。缺点：CPU内存开销较大。
  
     2.信号量方式：底层使用原子计数器(atomic)，针对于每个服务都设置自己的独立的限制阈值。比如设置每个服务接口最多同时访问的次数，如果超出缓存队列请求后，自己实现拒绝策略。


*  熔断

> 在高并发的情况下，如果达到一定的极限(可以自己设置阈值),如果流量超出了设置的阈值，然后拒绝访问，保护当前服务。当服务器达到最大的承受能力的之后，直接拒绝访问服务，然后调用降级方法，返回友好提示。
  
  目的：为了防止服务宕机(保护服务)，会进行熔断处理。
  
  产生的原因：服务请求过多，高并发情况下。可以设置阈值进行限制。超出的请求存放在缓存队列中，如果缓存队列中线程满的话，直接拒绝访问服务，访问不了服务(熔断)。

## 用线程池还是信号量隔离

如果异步IO密集(http, 数据库)请求，用线程池

如果计算密集请求，用信号量，走的是tomcat线程
	 
	  
```
	  try{
	  
	      1.   发起向服务方的请求;
	      		1.1 判断连接超时
	      			-> 这次请求 记录到服务里
	      		http请求  线程消耗
	      
	      
	      		map(URI,线程数) 
	      		线程池（线程数）
	         阈值 阀值
	         
	         计数 连续失败次数 达到阈值 
	         count ++；
	      if(count == 10){
	      
	      new romdom  == 1  按时间
	        发请求
	      
	      
	      	throw exception;
	      }
	      
	      
	          请求/不请求/半请求
	          开      关         半开
	      
	      if （当前线程满了）{
	      	throw exception
	      }
	      		
	      
	      		1.2 尝试向其他服务器发起请求
	      
	      
	      注解
	      
	      
	      2. 还是没成功
	      
	      }catch(Exception e){
	      
	      	1.	避免返回不友好的错误信息
	      			-> 好看点儿的页面  重试按钮 联系邮箱
	      
	      		
	      	2.	return 另外一个东西 写到MQ里 admin 发个邮件
	      
	      		return "客观稍后再来"；
	      
	      }

```	  

